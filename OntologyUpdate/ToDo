==== ARQ ToDo

** Clean up
   Properties file for version in ARQ.class
   Using new build systems
     Separate out into a build area; use ivy (no source etc)
     Or Make multiple jar artifacts

** Quads and the quad engine - better as a dynamic transform? See dev.Quadization

** Paths 
  + {0} to be an assignment? 

+ Precedence-driven printing PathWriter.

** Stricter rules for property functions - must bind all variables => can do FILTER migration across them.

See ToDoSSE

----

+ Prefixes for a query from a model.
  Abbreviates access match("pattern", model) and get prefixes from model.

+ extra jar - testing only.

+ Document StageGenerator

+ List handling on own documentation page

+  FROM <.....n3>
   but it's application/rdf+xml
   believe MIME type.
   Jena change: FileManager/MimeStream

+ SUM [done], MIN, MAX, AVG, (STDDEV)
   MINI, MINN, MIND

+ EXISTS { pattern } as FILTER 

+ Tutorial on update 
   Separate out list PFs like free text.

+ Wrapper to have all functions as assignments

+ ORDER BY COUNT(*) [Partially done]
  i.e. add to the assignments.
  c.f SELECT
  AlgebraGenerator/compileModifiers(Query, Op)

+ More dateTime arithmetic and durations
  http://www.w3.org/TR/xpath-functions/#dateTime-arithmetic

+ What is "OpDatasetNames" nowadays? yes.
	A table?  unnecessary?
	+ Remove OpDatasetNames?? - only needed in quad compilation for GRAPH ?g {}
  Do that a better way (join of all names).
  Or even a special iterator for OpCompiler? 

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
== LARQ

+ LARQ assembler

+ Implement IndexBuilderLiter.unindexStatement

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

== Other

+ ResultsFormat (output)vs ResultSetFormat (input)
  ResultSetFormatter.output as SSE
  ResultSetFactory input as SSE

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
